---
layout: post
title: Value Classes, and what they mean for You
---

How does one refer to `-1i8`? To `std::f32::INFINITY`? To `[255u8, 127]`?

# Values

# Rvalues vs Lvalues

An "rvalue" is the ephemeral "idea" of a value; it's not the manifestation of a
real value, put into a place, it is only an intermediate state. An rvalue is
*only* a concept; that is an important fact to understand, and differs
completely from C++.

An "lvalue" is real, it has a real place, it exists; there is backing storage that
will still exist after the expression is done. More technically, an lvalue has an
address you can take.

Rust is a language that has wavy boundaries between lvalue and rvalue; C has a
clear-cut boundary; you know exactly when you're going to allocate memory on
the stack, and when something is going to be a temporary (although this holds a
little less true now). I'll show you some examples from that language, where
the boundary is very strong:

```C
// declare the main function
int main() {
  // declare a variable "a" of type "int", set it to 0
  int lv = /*rv*/ 0;
  // lv is the lvalue here; it's real. it exists on the stack, in memory
  // '0' is the rvalue; it's just an ephemeral value 0 of type int that the
  // compiler knows

  // this is equivalent to "let ptr: &int = &lv;"
  int *ptr = &a;
  // int *ptr = &0;
  // this is not allowed in C, because C has *strict* lvalue-rvalue rules.
  // lv has an address; it exists on the stack, in memory. 0 does not
  // 0 is just an ephemeral value, it doesn't really exist
  // the literal 0 only exists to get stored into some place 

  // now let's get a little tricky
  int lv2 = lv;
  // > wait, what!? we just set an lvalue to an lvalue! how is this possible?
  // > Nicole, you told me that I could only set lvalues to rvalues.
  // well, the cool thing is, lvalues automatically get converted to rvalues!
  // this is what is known, shockingly, as an lvalue-rvalue conversion.
  // basically, it takes the value stored in the lvalue, and turns it into one
  // of those ephemeral rvalues, since lvalues are strictly more powerful.
}
```

Now let's get to Rust, a language with less strict lvalue-rvalue rules. How
does it deal with these issues? It still has them! Rust, however, errs on the
side of programmer usability.

```rust
fn main() {
  let lv = 0; // this makes sense; we're setting an lvalue to an rvalue
  // we have a memory location, and we have an ephemeral value
  // and we put the one, in the other
  let ptr = &lv;
  // still makes sense! now we put the location of lv into ptr.
  let lv2 = lv;
  // still going strong! Only caveat that's different from C is move
  // semantics which I won't be covering here:
  // see https://doc.rust-lang.org/book/ownership.html
  let ptr2 = &0;
  // do comment
}
```

talk more


